### GC垃圾回收器

1.判断一个类是否"无用",则需同时满足三个条件:

(1)该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。

(2)加载该类 ClassLoader 已经被回收

(3)该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类 的方法。

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的是可以回收而不是必然回收。

 

2.可达性分析算法(Reachability Analysis)

 这是Java虚拟机采用的判定对象是否存活的算法，通过一系列的称为 Gc Roots的对象作为起始点。

![image-20210608104734631](imags\内存结构扑朔图)

JDK1.8 JVM 内存布局:

![image-20210608104931315](imags\JDK1.8-JVM内存布局)



JVM内存模型：

![image-20210611151108430](imags\java代码具体执行过程)

运行时数据区，即jvm内存结构图如下图：

![image-20210611151129052](E:\笔记本Typora\技术\technology\imags\JVM内存模型)



#### 运行时数据区：

##### 1. 程序计数器（PC寄存器）

由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并不能互相被干扰。否则就会影响到程序的正常执行次序，因此，可以这么说，程序计数器是每个线程所私有的，由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变。因此，对于程序计数器是不会发生内存溢出现象的。

##### 2. java栈

Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括**局部变量表(Local Variables)**、**操作数栈(Operand Stack)**、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）**的引用**(Reference to runtime constant pool)、**方法返回地址(Return Address)**和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。

![image-20210611152250322](imags\java栈)

  



##### 3. 本地方法栈

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的

##### 4.堆

Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。

##### 5. 方法区

与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，

对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

#### 内存溢出

![image-20210611154013236](E:\笔记本Typora\技术\technology\imags\内存溢出)

